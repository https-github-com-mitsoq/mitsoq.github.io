{"version":3,"file":"SupButton.stories.2fa01ce1.js","sources":["../../src/utils/obj.js","../../src/components/SupButton/SupButton.vue"],"sourcesContent":["/**\n * return the *extended type of the provided expression.\n * *extended: JavaScript reports the type any of these (`null | {} | []` ) to be an `object`\n *      this function returns `null` in the case it finds a null value and `array` in the case it finds an Array\n *      all other object values are typed as 'object'\n * @example\n *      type([]) === 'array'\n *      type(null) === 'null'\n *      type() === 'undefined'\n *      type({}) === 'object'\n *      type(()=>{}) === 'function'\n *      type('test') === 'string'\n *      type(1) === 'number'\n *      type(Symbol()) === 'symbol'\n *\n * @static\n * @param {any} any The variable or expression to test.\n * @param {Boolean} [strict=false] If strict is true, null and Array also return 'object'\n * @returns {String}\n */\nconst type = (any, strict = false) => {\n  let type = typeof any\n  if (type === 'object') {\n    if (strict) return type\n    if (any === null) return 'null'\n    if (Array.isArray(any)) return 'array'\n    if (any instanceof RegExp) return 'regex'\n    if (any instanceof Error) return 'error'\n    return type\n  } else {\n    return type\n  }\n}\n\n/**\n * Test whether an object contains a definition at the provided namespace\n * @example\n *      has({a:{b:{c:'something'}}}, 'a.b.c') === true\n *\n * @static\n * @param {any} obj The object to inspect\n * @param {String} namespace The dot-saparated namespace to test\n * @param {boolean} allowInherit\n * @returns {any}\n * @memberof Obj\n */\nconst has = (obj, namespace, allowInherit = true) => {\n  if (type(namespace) !== 'array') namespace = String(namespace).split('.')\n  if (namespace.length > 0) {\n    const nextProp = namespace.shift()\n    if (obj !== null && typeof obj === 'object') {\n      if (allowInherit ? nextProp in obj : Object.prototype.hasOwnProperty.apply(obj, [nextProp])) {\n        return has(obj[nextProp], namespace, allowInherit)\n      } else {\n        return false\n      }\n    } else {\n      return false\n    }\n  }\n  return true\n}\n\n/**\n * Fetch the value of a namespace contained in an object, and return the defaultValue if such a namespace\n * could not be found.\n * @example\n *      get({a:{b:{c:'test string'}}}, 'a.b.c') === 'test string'\n *      get({a:{b:{c:'test string'}}}, 'a.b.d') === undefined\n *      get({a:{b:{c:'test string'}}}, 'a.b.d', null) === null\n *\n * @static\n * @param {any} obj The object to use as base\n * @param {String} namespace The namespace to fetch the value of\n * @param {any} defaultValue The default value returned if the namespace is not found on the object\n * @param {boolean} allowInherit\n * @returns {any}\n * @memberof Obj\n */\nconst get = (obj, namespace, defaultValue, allowInherit = true) => {\n  if (type(namespace) !== 'array') namespace = String(namespace).split('.')\n  if (namespace.length > 0) {\n    const nextProp = namespace.shift()\n    if (obj !== null && typeof obj === 'object') {\n      if (allowInherit ? nextProp in obj : Object.prototype.hasOwnProperty.apply(obj, [nextProp])) {\n        return get(obj[nextProp], namespace, defaultValue, allowInherit)\n      } else {\n        return defaultValue\n      }\n    } else {\n      return defaultValue\n    }\n  }\n  return obj\n}\n\nconst isObject = (any, strict) => {\n  return type(any, strict) === 'object'\n}\n\nconst isArray = any => {\n  return type(any) === 'array'\n}\n\nconst isNull = any => {\n  return type(any) === 'null'\n}\n\nconst isUndefined = any => {\n  return type(any) === 'undefined'\n}\n\nconst isRegex = any => {\n  return type(any) === 'regex'\n}\n\nconst isString = any => {\n  return type(any) === 'string'\n}\n\nconst isNumber = any => {\n  return type(any) === 'number'\n}\n\nconst isFunction = any => {\n  return type(any) === 'function'\n}\n\nconst isSymbol = any => {\n  return type(any) === 'symbol'\n}\n\nconst isError = any => {\n  return type(any) === 'error'\n}\n\n/**\n * Check whether the `obj` value at `namespace` has the type `type`\n * @example\n *  propIsType({a:{b:{c:null}}},'a.b.c','null') === true\n *\n * @static\n * @param {any} obj The object to be inspected\n * @param {String} namespace The namespace contained in the object, to be inspected\n * @param {String} type The type name being tested for\n * @param {Boolean} [strict=false] with `strict===false` an array would be typed 'array'. With `strict===false` an\n * array would be typed 'object'\n * @returns {Boolean}\n */\nconst propIsType = (obj, namespace, type, strict = false) => {\n  const notFound = Symbol('notFound') // unique unreproducible value\n  const value = get(obj, namespace, notFound)\n  const typeString = type(value, strict)\n  return notFound === value ? false : typeString === type\n}\n\n/**\n *\n * Check whether the `obj` value at `namespace` has the type `undefined`, returns appropriately with true if\n * namespace does not exist.\n *\n * The difference between hasUndefined and propIsType(,,'undefined'), is that hasUndefined returns true\n * if a , a.b or a.b.c is undefined. Instead of returning false if a or a.b isn't defined.\n *\n * @example\n *  hasUndefined({a:{b:{c:undefined}}},'a.b.c') === true\n *  hasUndefined({a:{}},'a.b.c') === true\n *\n * @param {any} obj The object to be inspected\n * @param {String} namespace The namespace contained in the object, to be inspected\n */\nconst hasUndefined = (obj, namespace) => {\n  return get(obj, namespace, undefined) === undefined\n}\n\n/**\n * returns true if the passed argument can be iterated over\n *\n * @static\n * @param {*} obj The variable to test\n * @returns\n */\nconst canIterate = obj => {\n  return ['object', 'array'].indexOf(type(obj)) >= 0\n}\n\n/**\n * Get an array of errors when validating a data object against a schema\n * @example\n *   let bookShema = {\n *       'title': 'string',\n *       '?ISBN': /ISBN\\x20(?=.{13}$)\\d{1,5}([- ])\\d{1,7}\\1\\d{1,6}\\1(\\d|X)$/,\n *       'primeKey': num => {\n *           for (let i = 2, s = Math.sqrt(num); i <= s; i++)\n *               if (num % i === 0) return false;\n *           return num > 1;\n *       },\n *       'author': {\n *           'name': 'string',\n *           'surname': 'string',\n *           '?misc': 'any',\n *           '?co-authors': [{\n *               'name': 'string',\n *               'surname': 'string',\n *               '?editorOnly': 'boolean|undefined'\n *           }]\n *       },\n *   }\n *   let book = {\n *       title: 'Some Title',\n *       ISBN: 'ISBN 1-56389-668-0',\n *       dewey: '1.23',\n *       primeKey: 9,\n *       author: {\n *           'name': 'Peter',\n *           'surname': 'Pan',\n *           'co-authors': [{\n *               'name': 'Wendy',\n *               'surname': '',\n *               'editorOnly': 'yes'\n *           }]\n *       }\n *   }\n *\n *   console.log(getSchemaErrors(book,bookShema))\n *\n *   $> [\n *   $>     \"'dewey' is not defined in the schema.\",\n *   $>     \"'primeKey' does not pass the validation function for that property.\",\n *   $>     \"'author.co-authors.0.editorOnly' is not of type 'boolean | undefined'\"\n *   $> ]\n *\n *\n * @static\n * @param {*} obj The object to test\n * @param {*} schema The Schema to test against\n * @returns\n */\nconst getSchemaErrors = (obj, schema) => {\n  //Custom error for .reasons\n  class CheckSchemaError extends Error {\n    constructor(message, reasons = null) {\n      super(message)\n      this.reasons = reasons\n    }\n  }\n\n  if (!canIterate(obj)) throw new CheckSchemaError('Invalid object or schema')\n\n  const makeValidationFunction = (validationSpec, fullPropName) => {\n    const validationSpecType = type(validationSpec)\n    let validationFunction = () => false // fail by default\n\n    ;((validationSpec, validationSpecType, fullPropName) => {\n      // to avoid leakage over multiple calls\n      switch (validationSpecType) {\n        case 'array':\n          if (validationSpec.length !== 1)\n            throw new CheckSchemaError(\n              `Array schema for '${fullPropName}' should contain exactly one object indicating validation spec for array items`\n            )\n          validationFunction = data => {\n            let errors = []\n            if (!Array.isArray(data))\n              throw new CheckSchemaError(`'${fullPropName}' is expected to be an array of objects`)\n            data.forEach((item, idx) => {\n              if (type(item) !== 'object')\n                throw new CheckSchemaError(\n                  `'${[...fullPropName.split('.'), idx].join('.')}' is expected to be an object`\n                )\n              try {\n                checkSchema(item, validationSpec[0], [...fullPropName.split('.'), idx])\n              } catch (e) {\n                errors.push(e)\n              }\n            })\n            let reasons = colateErrors(errors)\n            if (reasons.length > 0) throw new CheckSchemaError('Array validation failures', reasons)\n          }\n          break\n        case 'object':\n          validationFunction = data => {\n            checkSchema(data, validationSpec, fullPropName.split('.'))\n          }\n          break\n\n        //     break\n        case 'regex':\n          validationFunction = data => {\n            const valid = `${data}`.match(validationSpec)\n            if (!valid)\n              throw new CheckSchemaError(\n                `'${fullPropName}' does not pass the regex '${validationSpec.toString()}'.`\n              )\n            return true\n          }\n          break\n        case 'function':\n          validationFunction = data => {\n            const valid = !!validationSpec(data)\n            if (!valid)\n              throw new CheckSchemaError(\n                `'${fullPropName}' does not pass the validation function for that property.`\n              )\n            return true\n          }\n          break\n        case 'string':\n          validationFunction = data => {\n            let types = validationSpec.split('|')\n            const valid = types.indexOf(type(data)) >= 0 || types.indexOf('any') >= 0\n            if (!valid)\n              throw new CheckSchemaError(`'${fullPropName}' is not of type '${types.join(' | ')}'`)\n            return true\n          }\n          break\n      }\n    })(validationSpec, validationSpecType, fullPropName)\n\n    return validationFunction\n  }\n\n  const colateErrors = errorArray => {\n    let reasons = []\n    errorArray.forEach(error => {\n      if (Array.isArray(error.reasons)) {\n        // console.log(error)\n        reasons = reasons.concat(error.reasons)\n      } else {\n        reasons.push(error.message)\n      }\n    })\n    return reasons\n  }\n\n  const checkSchema = (obj, schema, prefix = []) => {\n    let propSchemas = {}\n    ;(() => {\n      // isolate scope\n      let props = Object.keys(schema)\n      for (let prop of props) {\n        let propSchema = {}\n        propSchema.required = prop[0] !== '?'\n        propSchema.prop = propSchema.required ? prop : prop.substring(1)\n        propSchema.fullProp = [...prefix, propSchema.prop].join('.')\n        propSchema.validation = makeValidationFunction(schema[prop], propSchema.fullProp)\n        propSchemas[propSchema.prop] = propSchema\n      }\n    })()\n    // console.log('VALIDATION', { obj, schema, prefix, propSchemas })\n\n    let errors = []\n\n    //Check minimum properties\n    Object.values(propSchemas)\n      .filter(propSchema => propSchema.required)\n      .map(propSchema => propSchema) //is required\n      .filter(propSchema => !Object.prototype.hasOwnProperty.apply(obj, [propSchema.prop])) //is not on obj\n      .forEach(propSchema => {\n        errors.push(new CheckSchemaError(`'${propSchema.fullProp}' is a required property.`))\n      })\n\n    //No extra data\n    let allSchemaProperties = Object.keys(propSchemas)\n    Object.keys(obj)\n      .filter(prop => allSchemaProperties.indexOf(prop) < 0)\n      .forEach(illegalProp => {\n        errors.push(\n          new CheckSchemaError(\n            `'${[...prefix, illegalProp].join('.')}' is not defined in the schema.`\n          )\n        )\n      })\n\n    //Validate each property\n    Object.values(propSchemas)\n      .map(propSchema => propSchema) //is required\n      .filter(propSchema => Object.prototype.hasOwnProperty.apply(obj, [propSchema.prop])) //is on obj\n      .forEach(propSchema => {\n        try {\n          propSchema.validation(obj[propSchema.prop])\n        } catch (e) {\n          errors.push(e)\n        }\n      })\n\n    let reasons = colateErrors(errors)\n    if (reasons.length > 0) {\n      throw new CheckSchemaError(`Schema validation failed`, reasons)\n    }\n    return true\n  }\n\n  try {\n    checkSchema(obj, schema)\n    return []\n  } catch (e) {\n    return colateErrors([e])\n  }\n}\n\n/**\n * Recursively flatten an object\n *\n * @example\n *\n *  let flattened = flatten({\n *      title: 'Some Title',\n *      ISBN: 'ISBN 1-56389-668-0',\n *      dewey: '1.23',\n *      primeKey: 9,\n *      author: {\n *          'name': 'Peter',\n *          'surname': 'Pan',\n *          'co-authors': [{\n *              name: 'Wendy',\n *              surname: '',\n *              editorOnly: 'yes'\n *          }]\n *      }\n *  })\n *\n *  console.log(flattened)\n *  $> {\n *  $>     \"title\": 'Some Title',\n *  $>     \"ISBN\": 'ISBN 1-56389-668-0',\n *  $>     \"dewey\": '1.23',\n *  $>     \"primeKey\": 9,\n *  $>     'author.name': 'Peter',\n *  $>     'author.surname': 'Pan',\n *  $>     'author.co-authors.0.name': 'Wendy',\n *  $>     'author.co-authors.0.surname': '',\n *  $>     'author.co-authors.0.editorOnly': 'yes'\n *  $> }\n *\n * @static\n * @param {*} obj\n * @param {*} [prefix=[]]\n * @returns {Object}\n * @memberof Obj\n */\nconst flatten = (obj, prefix = []) => {\n  if (['object', 'array'].indexOf(type(obj)) < 0) return false\n  let keys = Object.keys(obj)\n  // console.log('Object',obj,keys)\n  let out = {}\n  for (let key of keys) {\n    let value = obj[key]\n    if (['object', 'array'].indexOf(type(value)) >= 0) {\n      out = { ...out, ...flatten(value, [...prefix, key]) }\n    } else {\n      out[[...prefix, key].join('.')] = value\n    }\n  }\n  return out\n}\n\n/**\n * Interpolate a string with the marked up object properties\n *\n * @static\n * @param {Object} obj The object to use for interpolation\n * @param {string} str\n * @param {*} [defaultValue=undefined]\n * @returns {string}\n * @memberof Obj\n * @example\n *  interpolate({testProp:{nestedProp:[{arrayNestedProp:'propertyValue'}]}},'The value is: [testProp.nestedProp.0.arrayNestedProp]')\n *  // == The value is: propertyValue\n */\nconst interpolate = (obj, str, defaultValue) => {\n  let ostr = str\n\n  const regex = /\\[(.*?)\\]/g\n  let m\n  let keys = []\n\n  while ((m = regex.exec(str)) !== null) {\n    if (m.index === regex.lastIndex) regex.lastIndex++ // Avoid infinite loops\n    keys.push(m[1])\n  }\n  keys.forEach(key => {\n    const v = get(obj, key, defaultValue)\n    if (v !== undefined) {\n      const regex = new RegExp(`\\\\[${key}\\\\]`, 'gm')\n      ostr = ostr.replace(regex, v)\n    }\n  })\n\n  return ostr\n}\n\nexport {\n  type,\n  has,\n  get,\n  isObject,\n  isArray,\n  isNull,\n  isUndefined,\n  isRegex,\n  isString,\n  isNumber,\n  isFunction,\n  isSymbol,\n  isError,\n  propIsType,\n  hasUndefined,\n  canIterate,\n  getSchemaErrors,\n  flatten,\n  interpolate,\n}\n","<template>\n  <button\n    class=\"btn\"\n    :class=\"[classes, variants]\"\n    :disabled=\"isDisabled\"\n    :name=\"label\"\n    :aria-label=\"label\"\n    @click=\"onClick\"\n  >\n    <slot></slot>{{ label }}\n  </button>\n</template>\n\n<script>\nimport { computed, reactive } from 'vue'\nimport { has, get } from '../../utils/obj'\n\nconst types = {\n  primary: ['btn--primary'],\n  secondary: ['btn--secondary'],\n  tertiary: ['btn--tertiary'],\n  quaternary: ['btn--quaternary'],\n}\n\nconst visuals = {\n  black: ['btn--black', 'white'],\n  green: ['btn--green', 'white'],\n  red: ['btn--red', 'white'],\n  white: ['btn--white', 'black'],\n}\n\nexport default {\n  name: 'SupButton',\n  props: {\n    type: {\n      type: String,\n      required: true,\n      validator(value) {\n        return has(types, value)\n      },\n    },\n    background: {\n      type: String,\n      required: true,\n      validator(value) {\n        return has(visuals, value)\n      },\n    },\n    label: {\n      type: String,\n      default: '',\n    },\n    disabled: {\n      type: Boolean,\n      default: false,\n    },\n  },\n  setup(props, { emit }) {\n    props = reactive(props)\n\n    const classes = computed(() => get(types, props.type, {}))\n    const variants = computed(() => get(visuals, props.background, {}))\n    const isDisabled = computed(() => JSON.parse(props.disabled))\n\n    const onClick = () => {\n      emit('click')\n    }\n\n    return { classes, variants, isDisabled, onClick }\n  },\n}\n</script>\n\n<style lang=\"scss\" scoped>\n//Component options namespaced as modifiers (\"--\").\n@mixin modifier($name) {\n  //Get the parent component name.\n  $component: str-slice(#{&}, 0, -1);\n  &--#{$name} {\n    @content;\n  }\n}\n\n.btn {\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  flex: 1;\n  font-family: 'Source Sans Pro', sans-serif;\n  font-size: 16px;\n  height: 40px;\n  width: 300px;\n  color: #000;\n  border: 0;\n  border-radius: 2px;\n  max-width: 100%;\n  padding: 10px 15px;\n  margin: 0 0 10px;\n  text-transform: uppercase;\n  outline: none;\n  transition: all ease-in-out 0.2s;\n  cursor: pointer;\n\n  @include modifier('red') {\n    background: red;\n  }\n\n  @include modifier('black') {\n    background: #000;\n  }\n\n  &:hover,\n  &:focus {\n    opacity: 0.9;\n  }\n}\n.white {\n  color: #fff;\n}\n</style>\n"],"names":["type","any","strict","has","obj","namespace","allowInherit","nextProp","get","defaultValue","types","visuals","_sfc_main","value","props","emit","reactive","classes","computed","variants","isDisabled","_createElementBlock","_normalizeClass","$setup","$props","args","_renderSlot","_ctx"],"mappings":"0JAoBA,MAAMA,EAAO,CAACC,EAAKC,EAAS,KAAU,CACpC,IAAIF,EAAO,OAAOC,EAClB,OAAID,IAAS,SACPE,EAAeF,EACfC,IAAQ,KAAa,OACrB,MAAM,QAAQA,CAAG,EAAU,QAC3BA,aAAe,OAAe,QAC9BA,aAAe,MAAc,QAC1BD,EAEAA,CAEX,EAcMG,EAAM,CAACC,EAAKC,EAAWC,EAAe,KAAS,CAEnD,GADIN,EAAKK,CAAS,IAAM,UAASA,EAAY,OAAOA,CAAS,EAAE,MAAM,GAAG,GACpEA,EAAU,OAAS,EAAG,CACxB,MAAME,EAAWF,EAAU,MAAO,EAClC,OAAID,IAAQ,MAAQ,OAAOA,GAAQ,WAC7BE,EAAeC,KAAYH,EAAM,OAAO,UAAU,eAAe,MAAMA,EAAK,CAACG,CAAQ,CAAC,GACjFJ,EAAIC,EAAIG,GAAWF,EAAWC,CAAY,EAK5C,EAEV,CACD,MAAO,EACT,EAkBME,EAAM,CAACJ,EAAKC,EAAWI,EAAcH,EAAe,KAAS,CAEjE,GADIN,EAAKK,CAAS,IAAM,UAASA,EAAY,OAAOA,CAAS,EAAE,MAAM,GAAG,GACpEA,EAAU,OAAS,EAAG,CACxB,MAAME,EAAWF,EAAU,MAAO,EAClC,OAAID,IAAQ,MAAQ,OAAOA,GAAQ,WAC7BE,EAAeC,KAAYH,EAAM,OAAO,UAAU,eAAe,MAAMA,EAAK,CAACG,CAAQ,CAAC,GACjFC,EAAIJ,EAAIG,GAAWF,EAAWI,EAAcH,CAAY,EAK1DG,CAEV,CACD,OAAOL,CACT,EC7EA,MAAMM,EAAQ,CACZ,QAAS,CAAC,cAAc,EACxB,UAAW,CAAC,gBAAgB,EAC5B,SAAU,CAAC,eAAe,EAC1B,WAAY,CAAC,iBAAiB,CAChC,EAEMC,EAAU,CACd,MAAO,CAAC,aAAc,OAAO,EAC7B,MAAO,CAAC,aAAc,OAAO,EAC7B,IAAK,CAAC,WAAY,OAAO,EACzB,MAAO,CAAC,aAAc,OAAO,CAC/B,EAEKC,EAAU,CACb,KAAM,YACN,MAAO,CACL,KAAM,CACJ,KAAM,OACN,SAAU,GACV,UAAUC,EAAO,CACf,OAAOV,EAAIO,EAAOG,CAAK,CACxB,CACF,EACD,WAAY,CACV,KAAM,OACN,SAAU,GACV,UAAUA,EAAO,CACf,OAAOV,EAAIQ,EAASE,CAAK,CAC1B,CACF,EACD,MAAO,CACL,KAAM,OACN,QAAS,EACV,EACD,SAAU,CACR,KAAM,QACN,QAAS,EACV,CACF,EACD,MAAMC,EAAO,CAAE,KAAAC,GAAQ,CACrBD,EAAQE,EAASF,CAAK,EAEtB,MAAMG,EAAUC,EAAS,IAAMV,EAAIE,EAAOI,EAAM,KAAM,CAAA,CAAE,CAAC,EACnDK,EAAWD,EAAS,IAAMV,EAAIG,EAASG,EAAM,WAAY,CAAA,CAAE,CAAC,EAC5DM,EAAaF,EAAS,IAAM,KAAK,MAAMJ,EAAM,QAAQ,CAAC,EAM5D,MAAO,CAAE,QAAAG,EAAS,SAAAE,EAAU,WAAAC,EAAY,QAJxB,IAAM,CACpBL,EAAK,OAAO,CACd,CAEgD,CACjD,CACH,wEArEEM,EASS,SAAA,CARP,MAAMC,EAAA,CAAA,MACG,CAAAC,EAAA,QAASA,EAAQ,QAAA,CAAA,CAAA,EACzB,SAAUA,EAAU,WACpB,KAAMC,EAAK,MACX,aAAYA,EAAK,MACjB,4BAAOD,EAAO,SAAAA,EAAA,QAAA,GAAAE,CAAA,KAEfC,EAAaC,EAAA,OAAA,UAAA,CAAA,EAAA,OAAA,EAAA,MAAGH,EAAK,KAAA,EAAA,CAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;"}